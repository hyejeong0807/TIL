# Chapter 1
## Operating system interfaces

운영체제의 역할은 다중 프로그램 사이의 컴퓨터를 공유하고 유용한 서비스 집합을 제공합니다. 

운영체제는 로우 레벨의 하드웨어를 관리하고 추상화하기 때문에 워드 프로세서가 어떤 유형의 디스크 하드웨어를 사용하는지에 대해 고려할 필요가 없습니다. 

운영체제는 동일한 시간에 다중 프로그램이 실행되도록 하드웨어를 공유합니다. 

마지막으로, 운영체제는 함께 데이터와 작업을 공유할 수 있도록 하여 상호작용을 위한 제어 방식을 제공합니다. 

![fig1-1](/os/xv6/helloworld/img/fig1-1.png)

그림 1.1은 xv6가 실행 중인 프로그램에 서비스를 제공하는 특별한 프로그램인 커널의 일반적인 형태를 취하고 있음을 보여줍니다. 

각 실행하는 프로그램을 프로세스라 부르며 명령어, 데이터, 스택을 포함하는 메모리를 가집니다. 

명령어는 프로그램의 계산을 구현하고, 데이터는 계산을 수행하는 변수, 스택은 프로그램의 프로시저 콜을 구성합니다. 특정 컴퓨터에는 일반적으로 많은 프로세스가 있지만 커널은 한 개 뿐입니다. 

프로세스가 커널 서비스 호출이 필요할 때 운영체제의 인터페이스 호출 중 하나인 시스템 콜을 호출합니다. 시스템 콜은 커널에 들어가고 커널은 서비스를 수행하여 반환합니다. 따라서 프로세스는 유저 공간과 커널 공간 사이에서 번갈아 실행됩니다. 

커널은 CPU에 의해 제공되는 하드웨어 보호 메커니즘을 사용하여 유저 공간에서 실행되는 각 프로세스가 오직 자신의 메모리 공간에만 액세스할 수 있도록 합니다. 

커널은 그러한 보호를 구현하기 위해 필요한 하드웨어 권한을 가지고 실행합니다. 유저 프로그램은 그러한 권한 없이 실행합니다. 유저 프로그램이 시스템 콜을 호출할 때 하드웨어는 권한 레벨을 높이고 커널에서 사전 정렬된 함수를 실행하기 시작합니다. 

커널이 제공하는 시스템 콜의 모음은 유저 프로그램이 보는 인터페이스입니다. xv6 커널은 서비스의 서브 집합과 유닉스 커널이 일반적으로 제공하는 시스템 골을 제공합니다. 

그림 1.2는 xv6의 시스템 콜의 목록을 보여줍니다. 
![fig1-2](/os/xv6/helloworld/img/fig1-2.png)

### 1.1 Processes and memory

xv6 프로세스는 유저 공간 메모리 (명령어, 데이터, 스택)과 커널 전용 프로세스별 상태로 구성됩니다. xv6는 실행을 대기 중인 프로세스의 집합 사이에 이용 가능한 CPU를 투명하게 전환하여 프로세스를 시분할 합니다. 프로세스가 실행 중이 아닐 때는 xv6는 CPU 레지스터를 저장하고 다음 프로세스가 실행할 때 복원합니다. 커널은 프로세스 식별자 (PID)를 각 프로세스와 연결합니다. 

포로세스는 fork 시스템 콜을 사용하여 새로운 프로세스를 생성합니다. fork는 새로운 프로세스를 생성하고 이를 child 프로세스라고 부릅니다. 이 child 프로세스는 parent 프로세스와 정확히 동일한 메모리 콘텐츠를 가지고 생성이 됩니다. fork는 parent와 child 두 개를 반환합니다. parent에서 fork는 child의 pid를 반환하고 child에서는 zero를 반환합니다. 

아래의 예는 C언어로 작성된 fork 예제 프로그램입니다. 

```
int pid = fork();
if (pid > 0) {
    printf("parent: child=%d\n", pid);
    pid = wait((int *) 0);
    printf("child %d is done\n", pid);
} else if (pid == 0) {
    printf("child: exiting\n");
    exit(0);
} else {
    printf("fork error\n");
}
```

exit 시스템 콜은 호출 프로세스의 실행을 중단하고 메모리 및 열린 파일과 같은 리소스를 해제합니다. exit는 정수 인자를 사용하고 0이면 성공 1이면 실패를 의미합니다. 

wait 시스템 호출은 현재 프로세스의 exited child의 pid를 반환하고 child의 exit 상태를 wait에 전달된 주소에 복사합니다. 만약 호출자의 child 중 하나라도 종료되지 않은 경우 wait은 종료될 때까지 기다립니다. 호출자가 child를 가지고 있지 않다면, wait 즉시 -1을 반환합니다. 만약 parent가 child의 exit 상태에 관여하지 않는다면 0을 전달하여 wait을 넘길 수 있습니다. 

