# Chapter 1
## Operating system interfaces

운영체제의 역할은 다중 프로그램 사이의 컴퓨터를 공유하고 유용한 서비스 집합을 제공합니다. 

운영체제는 로우 레벨의 하드웨어를 관리하고 추상화하기 때문에 워드 프로세서가 어떤 유형의 디스크 하드웨어를 사용하는지에 대해 고려할 필요가 없습니다. 

운영체제는 동일한 시간에 다중 프로그램이 실행되도록 하드웨어를 공유합니다. 

마지막으로, 운영체제는 함께 데이터와 작업을 공유할 수 있도록 하여 상호작용을 위한 제어 방식을 제공합니다. 

![fig1-1](/os/xv6/helloworld/img/fig1-1.png)

그림 1.1은 xv6가 실행 중인 프로그램에 서비스를 제공하는 특별한 프로그램인 커널의 일반적인 형태를 취하고 있음을 보여줍니다. 

각 실행하는 프로그램을 프로세스라 부르며 명령어, 데이터, 스택을 포함하는 메모리를 가집니다. 

명령어는 프로그램의 계산을 구현하고, 데이터는 계산을 수행하는 변수, 스택은 프로그램의 프로시저 콜을 구성합니다. 특정 컴퓨터에는 일반적으로 많은 프로세스가 있지만 커널은 한 개 뿐입니다. 

프로세스가 커널 서비스 호출이 필요할 때 운영체제의 인터페이스 호출 중 하나인 시스템 콜을 호출합니다. 시스템 콜은 커널에 들어가고 커널은 서비스를 수행하여 반환합니다. 따라서 프로세스는 유저 공간과 커널 공간 사이에서 번갈아 실행됩니다. 

커널은 CPU에 의해 제공되는 하드웨어 보호 메커니즘을 사용하여 유저 공간에서 실행되는 각 프로세스가 오직 자신의 메모리 공간에만 액세스할 수 있도록 합니다. 

커널은 그러한 보호를 구현하기 위해 필요한 하드웨어 권한을 가지고 실행합니다. 유저 프로그램은 그러한 권한 없이 실행합니다. 유저 프로그램이 시스템 콜을 호출할 때 하드웨어는 권한 레벨을 높이고 커널에서 사전 정렬된 함수를 실행하기 시작합니다. 

커널이 제공하는 시스템 콜의 모음은 유저 프로그램이 보는 인터페이스입니다. xv6 커널은 서비스의 서브 집합과 유닉스 커널이 일반적으로 제공하는 시스템 콜을 제공합니다. 

그림 1.2는 xv6의 시스템 콜의 목록을 보여줍니다. 
![fig1-2](/os/xv6/helloworld/img/fig1-2.png)

### 1.1 Processes and memory

xv6 프로세스는 유저 공간 메모리 (명령어, 데이터, 스택)과 커널 전용 프로세스별 상태로 구성됩니다. xv6는 실행을 대기 중인 프로세스의 집합 사이에 이용 가능한 CPU를 투명하게 전환하여 프로세스를 시분할 합니다. 프로세스가 실행 중이 아닐 때는 xv6는 CPU 레지스터를 저장하고 다음 프로세스가 실행할 때 복원합니다. 커널은 프로세스 식별자 (PID)를 각 프로세스와 연결합니다. 

포로세스는 fork 시스템 콜을 사용하여 새로운 프로세스를 생성합니다. fork는 새로운 프로세스를 생성하고 이를 child 프로세스라고 부릅니다. 이 child 프로세스는 parent 프로세스와 정확히 동일한 메모리 콘텐츠를 가지고 생성이 됩니다. fork는 parent와 child 두 개를 반환합니다. parent에서 fork는 child의 pid를 반환하고 child에서는 zero를 반환합니다. 

아래의 예는 C언어로 작성된 fork 예제 프로그램입니다. 

```
int pid = fork();
if (pid > 0) {
    printf("parent: child=%d\n", pid);
    pid = wait((int *) 0);
    printf("child %d is done\n", pid);
} else if (pid == 0) {
    printf("child: exiting\n");
    exit(0);
} else {
    printf("fork error\n");
}
```

exit 시스템 콜은 호출 프로세스의 실행을 중단하고 메모리 및 열린 파일과 같은 리소스를 해제합니다. exit는 정수 인자를 사용하고 0이면 성공 1이면 실패를 의미합니다. 

wait 시스템 호출은 현재 프로세스의 exited child의 pid를 반환하고 child의 exit 상태를 wait에 전달된 주소에 복사합니다. 만약 호출자의 child 중 하나라도 종료되지 않은 경우 wait은 종료될 때까지 기다립니다. 호출자가 child를 가지고 있지 않다면, wait 즉시 -1을 반환합니다. 만약 parent가 child의 exit 상태에 관여하지 않는다면 0을 전달하여 wait을 넘길 수 있습니다. 

Output lines: 
```
parent: child=1234
child: exiting
```
parent와 child가 printf 호출을 먼저 받는지에 따라 다른 순서로 나올 수 있습니다. child가 종료된 후 parent의 wait는 반환되어 다음과 같은 출력을 보여줍니다. 
```
parent: child 1234 is done
```
child는 처음 parent와 동일한 메모리 콘텐츠를 갖고 있지만, parent와 child는 다른 메모리와 다른 레지스터로 실행됩니다. 즉, 하나의 변수를 변경하여도 다른 하나는 영향을 받지 않습니다. 

예를 들어 wait의 반환 값이 parent 프로세스 pid에 저장되어질 때 child의 pid는 변경되지 않고 0입니다. 

exec 시스템 콜은 호출된 프로세스의 메모리를 파일 시스템에 저장된 파일에서 로드된 새로운 메모리 이미지로 교체합니다. 파일은 파일의 어떤 부분이 명령어를 담고 있는지 어떤 부분이 데이터인지 어느 명령어에서 시작할지를 명시하는 특정한 포맷을 가져야 합니다. exec이 성공하면 호출 프로그램에 돌아가지 않고 파일로 부터 로드된 명령어는 ELF 헤더에서 명시된 엔트리 포인트에서 실행을 시작합니다. exec은 실행 파일이 포함된 파일 이름과 문자열 인자 배열 이 두 가지 인자를 가집니다. 

```
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```
이 예제는 인자 목록 echo hello를 가지고 실행하는 프로그램 /bin/echo 인스턴스로 호출 프로그램을 교체합니다. 대부분의 프로그램은 인자 배열의 첫 번째 요소는 프로그램 이름이므로 무시합니다.  

### 1.2 I/O and File descriptors

